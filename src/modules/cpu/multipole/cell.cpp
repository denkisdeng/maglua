#include "cell.h"
#include <math.h>

Cell::Cell(dArray* X, dArray* Y, dArray* Z, Cell* Parent)
{
	x = luaT_inc<dArray>(X);
	y = luaT_inc<dArray>(Y);
	z = luaT_inc<dArray>(Z);
	
	bounds_low[0] = 0;
	bounds_low[1] = 0;
	bounds_low[2] = 0;

	bounds_high[0] = 1;
	bounds_high[1] = 1;
	bounds_high[2] = 1;
	
	for(int i=0; i<2; i++)
	{
		c[i] = 0;
	}
	
	parent = Parent;
	if(!parent) //this is the root and should have all members
	{
		for(int i=0; i<x->nxyz; i++)
			members.push_back(i);
	}
}


Cell::~Cell()
{
	if(c[0])
	{
		for(int i=0; i<2; i++)
			delete c[i];
	}

	luaT_dec<dArray>(x);
	luaT_dec<dArray>(y);
	luaT_dec<dArray>(z);
}

bool Cell::contains(double px, double py, double pz)
{
	if(px < bounds_low[0] || px >= bounds_high[0]) return false;
	if(py < bounds_low[1] || py >= bounds_high[1]) return false;
	if(pz < bounds_low[2] || pz >= bounds_high[2]) return false;
	return true;
}

void Cell::setBounds(double* low, double* high, int split_dir, int childNumber)
{
	for(int i=0; i<3; i++)
	{
		bounds_low[i] = low[i];
		bounds_high[i] = high[i];
	}

	const double mid = low[split_dir] + 0.5 * (high[split_dir] - low[split_dir]);
	if(childNumber == 0) //low
		bounds_high[split_dir] = mid;
	else
		bounds_low[split_dir] = mid;
}



void Cell::split(int split_dir, int until_contains)
{
	if(c[0]) return; //already split
	
	if((int)members.size() <= until_contains)
		return; //no need to split more
	

	for(int childNumber=0; childNumber<2; childNumber++)
	{
		c[childNumber] = new Cell(x, y, z, this);
		c[childNumber]->setBounds(bounds_low, bounds_high, split_dir, childNumber);
	}

	for(unsigned int i=0; i<members.size(); i++)
	{
		int j = members[i];
		for(int k=0; k<2; k++)
		{
			if(c[i]->contains( (*x)[j],  (*y)[j],  (*z)[j]))
			   c[k]->members.push_back(j);
		}
	}
	
	const int next_split = (split_dir + 1) % 3;
	
	if(until_contains > 0)
	{
		for(int i=0; i<2; i++)
			c[i]->split(next_split, until_contains);
	}
}

	
void Cell::getStats(double* meanXYZ, double* stddevXYZ)
{
	  meanXYZ[0] = 0;
	  meanXYZ[1] = 0;
	  meanXYZ[2] = 0;
	stddevXYZ[0] = 0;
	stddevXYZ[1] = 0;
	stddevXYZ[2] = 0;
	
	if(!x || members.size() == 0)
		return;
	
	double sum_weight = 0;
	
	for(unsigned int i=0; i<members.size(); i++)
	{
		int j=members[i];
		meanXYZ[0] += (*x)[j];
		meanXYZ[1] += (*y)[j];
		meanXYZ[2] += (*z)[j];
		sum_weight += 1.0;
	}
	if(sum_weight == 0)
		sum_weight = 1.0;
	meanXYZ[0] /= sum_weight;
	meanXYZ[1] /= sum_weight;
	meanXYZ[2] /= sum_weight;
	
	for(unsigned int i=0; i<members.size(); i++)
	{
		int j=members[i];
		stddevXYZ[0] += pow((*x)[j] - meanXYZ[0], 2);
		stddevXYZ[1] += pow((*y)[j] - meanXYZ[1], 2);
		stddevXYZ[2] += pow((*z)[j] - meanXYZ[2], 2);
	}
	
	stddevXYZ[0] /= sum_weight;
	stddevXYZ[1] /= sum_weight;
	stddevXYZ[2] /= sum_weight;
	
	stddevXYZ[0] = sqrt(stddevXYZ[0]);
	stddevXYZ[1] = sqrt(stddevXYZ[1]);
	stddevXYZ[2] = sqrt(stddevXYZ[2]);
}




	
	
// double cell::updateField()
// IF this cell has parent THEN
// inherit the Taylor expansion from its parent with shift of origin;
// END IF
// FOR each cell in the “Partners” list
// add to the Taylor expansion of this cell the field generated by A;
// END FOR
// IF this cell has child THEN
// call its children’s updateField();
// calculate the total energy of this cell by the sum of the energy of its
// children;
// ELSE
// calculate smooth local field from the Taylor expansion contributed from
// all far cells;
// FOR each cell “A” in the “nearPartners” list
// add to the local field from each dipoles in A except when the dipole
// is located at the field point;
// END FOR
// calculate the energy of this cell by summing over all the dipole in it and
// divide the energy by 2 to eliminate double inclusion of the interaction
// energy
// END IF
// return the energy of this cell;
// END



void Cell::getCenter(double* c3) const
{
	for(int i=0; i<3; i++)
		c3[i] = bounds_low[i] + (bounds_high[i] - bounds_low[i]) * 0.5;
}


double Cell::radius() const
{
	const double rx = (bounds_high[0] - bounds_low[0]) * 0.5;
	const double ry = (bounds_high[1] - bounds_low[1]) * 0.5;
	const double rz = (bounds_high[2] - bounds_low[2]) * 0.5;
	return sqrt(rx*rx + ry*ry + rz*rz);
}

double Cell::centerCenterDistanceTo(const Cell* other) const
{
	double here[3];
	double there[3];
	
	getCenter(here);
	other->getCenter(there);
	
	const double rx = here[0] - there[0];
	const double ry = here[1] - there[1];
	const double rz = here[2] - there[2];
	return sqrt(rx*rx + ry*ry + rz*rz);
}


double Cell::openingAngle(const Cell* other) const
{
	return 2.0*radius() / centerCenterDistanceTo(other);
}

bool Cell::near(const Cell* other) const
{
	return openingAngle(other) > 0.5; // ALPHA M
}

int Cell::removeFromPartnerList(Cell* c)
{
	vector<Cell*>::iterator it;
	for(it=partners.begin(); it!=partners.end(); ++it)
	{
		if(*it == c)
		{
			partners.erase(it);
			return 1;
		}
	}
	return 0;
}

void Cell::createPartners()
{
	for(unsigned int i=0; i<partners.size(); i++)
	{
		Cell* A = partners[i];
		if(near(A))
		{
			if(c[0])
			{
				
				if(A->c[0])
				{
					c[0]->partners.push_back(A->c[0]);
					c[0]->partners.push_back(A->c[1]);
					c[1]->partners.push_back(A->c[0]);
					c[1]->partners.push_back(A->c[1]);
				}
				
				i -= removeFromPartnerList(A);
			}
			else
			{
				nearPartners.push_back(A);
				removeFromPartnerList(A);
			}
		}
	}
	
	if(c[0])
	{
		c[0]->partners.push_back(c[1]);
		c[1]->partners.push_back(c[0]);
		c[0]->createPartners();
		c[1]->createPartners();
	}
	else
	{
		nearPartners.push_back(this);
	}
}






// void cell::updateMoment()
// clear the multipole moments of this cell;
// IF this cell is not the smallest cell Then
// call its children’s updateMoment();
// sum over its children’s multipole moment with shift of origin;
// ELSE IF there is dipoles in this smallest cell THEN
// calculate the multipole moments of this cell directly from the dipole
// distributions;
// END IF
// END FUNCTION
void Cell::updateMoment()
{
	moment->zero();
	smoothField->zero();

	if(c[0])
	{
		c[0]->updateMoment();
		c[1]->updateMoment();
	}
	else //leaf - pure dipoles
	{
		// equation 3
	}
}













